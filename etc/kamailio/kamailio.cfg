#!KAMAILIO
#
# Based on Kamailio SIP Server v5.2 - default configuration script
#     - web: https://www.kamailio.org
#     - git: https://github.com/kamailio/kamailio
#
# Refer to the Core CookBook at https://www.kamailio.org/wiki/
# for an explanation of possible statements, functions and parameters.
#

####### Configuration #########

# This proxy's IP address (this machine) - internal if NAT
#!define IPADDRESS "10.0.0.6"

#!define MULTIDOMAIN 0

# Destination for traffic - the PABX!
#!define SWITCH_ADDRESS "10.0.0.4"
pabx.ip = SWITCH_ADDRESS desc "Switch IP Address"
pabx.tcpport = "5060" desc "TCP Port"
pabx.tlsport = "5061" desc "TLS Port"

# Subsitution - Configuration
#!substdef "!CERTPATH!/etc/letsencrypt/live/sbc.lordsomerscamp.org.au!g"
#!substdef "!PRIVATE_IP!10.0.0.6!g"
#!substdef "!EXTERNAL_IP!52.189.194.44!g"

#!define EXTERNAL_NAME1 "sbc.lordsomerscamp.org.au"
#!define EXTERNAL_NAME2 "sbc.lordsomerscamp.com"
#!define EXTERNAL_NAME3 "sbc.lordsomerscamp.com.au"
#!define EXTERNAL_NAME4 "sbc.webstean.com"

# Subsitution - Listener
#!substdef "!SIP_PORT!5060!g"
#!substdef "!SIPS_PORT!5061!g"
#!substdef "!SCTP_PORT!5060!g"

## to be deleted
#######!define FLAG_FROM_PABX 1
#######!define FLAG_FROM_INTERNET 2

# SCTP protocol support (optional)
##!define WITH_SCTP

# MS TEAMS Direct Routing support (optional)
#!define WITH_MSTEAMS

# HOMER support (optional)
##!define WITH_HOMER

# NAT traversal support (optional)
##!define WITH_NAT

# - flags
#   FLT_ - per transaction (message) flags
#	FLB_ - per branch flags
#!define FLT_ACC 1
#!define FLT_ACCMISSED 2
#!define FLT_ACCFAILED 3
#!define FLT_NATS 5

#!define FLB_NATB 6
#!define FLB_NATSIPPING 7

#!define WITH_DEBUG

#!ifdef WITH_DEBUG
####!define DBGLEVEL 3
#!define DBGLEVEL 2
log_stderror=no
#!else
#!define DBGLEVEL 2
log_stderror=no
#!endif

####### Global Parameters #########
/* LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR, ... */
debug=DBGLEVEL
memdbg=5
memlog=5

log_facility=LOG_LOCAL0
#### log_prefix="{$mt $hdr(CSeq) $ci} "
log_prefix=""

/* Locks all Kamailio pages into memory making it unswappable */
#mlock_pages=yes

/* number of SIP routing processes for each socket
 * - value inherited by tcp_children and sctp_children when not set explicitely */
children=4

/* number of SIP routing processes for all TCP/TLS sockets */
tcp_children=4

/* uncomment the next line to disable the auto discovery of local aliases
 * based on reverse DNS on IPs (default on) */
auto_aliases=yes

/* add local domain aliases - it can be set many times */
#!ifdef EXTERNAL_NAME1
alias=EXTERNAL_NAME1
#!endif
#!ifdef EXTERNAL_NAME2
alias=EXTERNAL_NAME2
#!endif
#!ifdef EXTERNAL_NAME3
alias=EXTERNAL_NAME3
#!endif
#!ifdef EXTERNAL_NAME4
alias=EXTERNAL_NAME4
#!endif
#!ifdef EXTERNAL_NAME5
alias=EXTERNAL_NAME5
#!endif
#!ifdef EXTERNAL_NAME6
alias=EXTERNAL_NAME6
#!endif

/* life time of TCP connection when there is no traffic
 * - a bit higher than registration expires to cope with UA behind NAT */
tcp_connection_lifetime=3605

/* upper limit for TCP connections (it includes the TLS connections) */
tcp_max_connections=2048

#!ifdef WITH_SCTP
enable_sctp=yes
#!else
enable_sctp=no
#!endif

/* Enable TLS Support */
enable_tls=yes
/* upper limit for TLS connections */
tls_max_connections=2048

## Obscure
user_agent_header="User-Agent: Kamailio"
server_header="Server: Kamailio"
sip_warning=yes

####### Custom Parameters #########

/* These parameters can be modified runtime via RPC interface
 * - see the documentation of 'cfg_rpc' module.
 *
 * Format: group.id = value 'desc' description
 * Access: $sel(cfg_get.group.id) or @cfg_get.group.id */

####### Modules Section ########
/* set paths to location of modules - adjust as required*/
##mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

/* tls module needs to enabled before any others */
loadmodule "tls.so"
/* ignore library check */
modparam("tls", "tls_force_run", 11)
modparam("tls", "config", "/etc/kamailio/tls.cfg")

/* set paths to location of modules */
loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "counters.so"
#!ifdef WITH_MSTEAMS
loadmodule "dispatcher.so"
#!endif
#!ifdef WITH_NAT
loadmodule "usrloc.so"
loadmodule "nathelper.so"
#!endif

# ----------------- setting module-specific parameters ---------------

# ----- xlog params -----
modparam("xlog", "force_color", 1)

#!ifdef WITH_MSTEAMS
# ----- dispatcher params -----
modparam("dispatcher", "list_file", "/etc/kamailio/msteams.list")
modparam("dispatcher", "ds_probing_mode", 1)
modparam("dispatcher", "ds_ping_interval", 60)
###modparam("dispatcher", "ds_ping_from", "sip:proxy@kamailio.org")
### use 'kamcmd dispatcher.list | egrep "URI|FLAGS"' to check status
#!endif

#!ifdef WITH_HOMER
loadmodule "siptrace.so"
# check IP and port of your capture node
modparam("siptrace", "duplicate_uri", "sip:10.0.0.1:9060")
# Send from an IP
modparam("siptrace", "send_sock_addr", "sip:10.2.0.2:5000")
modparam("siptrace", "hep_mode_on", 1)
modparam("siptrace", "trace_to_database", 0)
modparam("siptrace", "trace_flag", 22)
modparam("siptrace", "trace_on", 1)
#!endif

#!ifdef WITH_NAT
# ----- userloc params -----
modparam("usrloc", "timer_interval", 60)
modparam("usrloc", "timer_procs", 1)
modparam("usrloc", "use_domain", MULTIDOMAIN)

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.org")

# params needed for NAT traversal in other modules
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")
modparam("usrloc", "nat_bflag", FLB_NATB)
#!endif

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
/* set the path to RPC fifo control file */
modparam("jsonrpcs", "fifo_name", "/run/kamailio/kamailio_rpc.fifo")
/* set the path to RPC unix socket control file */
modparam("jsonrpcs", "dgram_socket", "/run/kamailio/kamailio_rpc.sock")

# ----- ctl params -----
/* set the path to RPC unix socket control file */
modparam("ctl", "binrpc", "unix:/run/kamailio/kamailio_ctl")

# ----- tm params -----
# auto-discard branches from previous serial forking leg
modparam("tm", "failure_reply_mode", 3)
# default retransmission timeout: 30sec
modparam("tm", "fr_timer", 30000)
# default invite retransmission timeout after 1xx: 120sec
modparam("tm", "fr_inv_timer", 120000)

# ----- rr params -----
# set next param to 1 to add value to ;lr param (helps with some UAs)
modparam("rr", "enable_full_lr", 0)
# do not append from tag to the RR (no need for this script)
modparam("rr", "append_fromtag", 0)

####### Listeners ########

### Set up listeners - if none set, Kamailio binds to all local IP addresses
### format listen variable: listen=[proto]:[localip]:[lport] advertise [publicip]:[pport]
listen=tls:PRIVATE_IP:SIPS_PORT advertise EXTERNAL_IP:SIPS_PORT
### - basic prototype (full prototype can be found in Wiki - Core Cookbook):
###   listen=[proto]:[localip]:[lport] advertise [publicip]:[pport]
listen=tcp:PRIVATE_IP:SIP_PORT advertise EXTERNAL_IP:SIP_PORT

# try not to allow UDP connections -its insecure
#listen=udp:PRIVATE_IP:SIP_PORT advertise EXTERNAL_IP:SIP_PORT

# SCTP support - most modern Linux will have the SCTP support
#!ifdef WITH_SCTP
listen=sctp:PRIVATE_IP:SCTP_PORT advertise EXTERNAL_IP:SCTP_PORT
#!endif

####### Routing Logic ########
/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {

	# per request initial checks
	route(REQINIT);

	# NAT detection
	route(NATDETECT);

#!ifdef WITH_HOMER
	setflag(22);
    #start duplication mode: m or M for message; t or T for transaction; d or D for dialog
    sip_trace_mode("t");
#!endif

	# info
	xlog("L_ERROR","=FILTERED=>: $rm from {$fu ($si:$sp)}\n");

	# CANCEL processing
	if (is_method("CANCEL")) {
		if (t_check_trans()) {
			route(RELAY);
		}
		exit;
	}

	# handle retransmissions
	if (!is_method("ACK")) {
		if(t_precheck_trans()) {
			t_check_trans();
			exit;
		}
		t_check_trans();
	}

	# handle requests within SIP dialogs
	route(WITHINDLG);

	### only initial requests (no To tag)

	# record routing for dialog forming requests (in case they are routed)
	# - remove preloaded route headers
	remove_hf("Route");

#!ifdef WITH_MSTEAMS
    if (is_method("INVITE|REFER") && $ru =~ "pstnhub.microsoft.com") {
        record_route_preset("EXTERNAL_NAME1:5061;transport=tls", "EXTERNAL_IP:5060");
    } else {
#!endif
		if (is_method("INVITE")) {
			record_route();
		}
#!ifdef WITH_MSTEAMS
	}
#!endif
	if (is_method("SUBSCRIBE")) {
		record_route();
	}

	### if ($rU==$null) {
	###	# request with no Username in RURI
	###	sl_send_reply("484","Address Incomplete");
	###	exit;
	### }

	# proxy away
	route(PROXY);

	exit;
}

# Update $du to set the destination address for proxying
route[PROXY] {
	# TCP
	$du = "sip:" + $sel(cfg_get.pabx.ip) + ":"
		+ $sel(cfg_get.pabx.tcpport) + ";transport=TCP";
	# TLS
	$du = "sip:" + $sel(cfg_get.pabx.ip) + ":"
		+ $sel(cfg_get.pabx.tlsport) + ";transport=TLS";
	
	if ($rP == "TLS" ) {
		$du = "sip:10.0.0.4:5061;transport=TLS";
	} else {
		$du = "sip:10.0.0.4:5060;transport=TCP";
	}
	#$du = "sip:" + SWITCH_ADDRESS + ":SIP_PORT";
	xlog("L_ERROR","Route: [$rm] {$fu ($si:$sp)} proxying ===> $du");

	route(RELAY);
}

# Info
route[STARTUP] {
#!ifdef WITH_SCTP
	xlog("L_ALERT","ALERT: SCTP support is enabled!");
#!endif

#!ifdef WITH_MSTEAMS
	xlog("L_ALERT","ALERT: Microsoft Teams support enabled!");
#!endif

#!ifdef WITH_HOMER
	xlog("L_ALERT","ALERT: HOMER support enabled!");
#!endif

#!ifdef WITH_NAT
	xlog("L_ALERT","ALERT: NAT traversal support enabled!");
#!endif
	return;
}

# Wrapper for relaying requests
route[RELAY] {

	# enable additional event routes for forwarded requests
	# - serial forking, RTP relaying handling, a.s.o.
	if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
		if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
	}
	if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
		if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
	}
	if (is_method("INVITE")) {
		if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
	}

	if (!t_relay()) {
		sl_reply_error();
	}
	exit;
}

# Per SIP request initial checks
route[REQINIT] {
	if($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent") {
		# silent drop for scanners - uncomment next line if want to reply
		# sl_send_reply("200", "OK");
		exit;
	}

	# Check for loops
	if (!mf_process_maxfwd_header("10")) {
		sl_send_reply("483","Too Many Hops");
		exit;
	}

	# Respond to KeepAlives
    if(is_method("OPTIONS") && uri==myself && $rU==$null) {
		sl_send_reply("200","Keepalive");
		exit;
	}

	# check the sanity of the message
	if(!sanity_check("1511", "7")) {
		xlog("L_ALERT","Malformed SIP message from $si:$sp\n");
		exit;
	}
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
	if (!has_totag()) return;

	# sequential request withing a dialog should
	# take the path determined by record-routing
	if (loose_route()) {
		if (is_method("BYE")) {
			setflag(FLT_ACC); # do accounting ...
			setflag(FLT_ACCFAILED); # ... even if the transaction fails
		} else if ( is_method("NOTIFY") ) {
			# Add Record-Route for in-dialog NOTIFY as per RFC 6665.
			record_route();
		}
		route(RELAY);
		exit;
	}

	if ( is_method("ACK") ) {
		if ( t_check_trans() ) {
			# no loose-route, but stateful ACK;
			# must be an ACK after a 487
			# or e.g. 404 from upstream server
			route(RELAY);
			exit;
		} else {
			# ACK without matching transaction ... ignore and discard
			exit;
		}
	}
	sl_send_reply("404","Not here");
	exit;
}

# Caller NAT detection
route[NATDETECT] {
#!ifdef WITH_NAT
	if (nat_uac_test("19")) {
		if (is_method("REGISTER")) {
			fix_nated_register();
		} else {
			if(is_first_hop()) {
				set_contact_alias();
			}
		}
		setflag(FLT_NATS);
	}
#!endif
	return;
}

# signaling updates for NAT traversal
route[NATMANAGE] {
#!ifdef WITH_NAT
	if (is_request()) {
		if(has_totag()) {
			if(check_route_param("nat=yes")) {
				setbflag(FLB_NATB);
			}
		}
	}
	if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) return;

	if (is_request()) {
		if (!has_totag()) {
			if(t_is_branch_route()) {
				add_rr_param(";nat=yes");
			}
		}
	}
	if (is_reply()) {
		if(isbflagset(FLB_NATB)) {
			if(is_first_hop())
				set_contact_alias();
		}
	}

	if(isbflagset(FLB_NATB)) {
		# no connect message in a dialog involving NAT traversal
		if (is_request()) {
			if(has_totag()) {
				set_forward_no_connect();
			}
		}
	}
#!endif
	return;
}

# Handle Blocking with APIBAN 
route[BLOCKIP] {
#!ifdef WITH_APIBAN
	if (src_ip!=myself) {
		xlog("L_ERROR","[R-BLOCKIP:$ci]: blocking $rm from $fu (IP:$si:$sp)\n");
		$sht(ipban=>$si) = 1;
	}
#!endif
	return;
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
	xlog("L_ERROR","new branch (outgoing): [$T_branch_idx] to $ru\n");
	route(NATMANAGE);
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
	xlog("L_ERROR","incoming reply: [$rm] with $rr $fu $ru to [$du] $tu\n");
	if(status=~"[12][0-9][0-9]") {
		route(NATMANAGE);
	}
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
	xlog("L_ALERT","ALERT: route failure $rm from $fu (IP:$si:$sp) : $xavp(_dsdst_=>attrs)\n");
	route(NATMANAGE);
	if (t_is_canceled()) exit;
}

#!ifdef WITH_MSTEAMS
# Manage Contact header for Microsoft Teams with Keepalive
event_route[tm:local-request] {
    if(is_method("OPTIONS") && $ru =~ "pstnhub.microsoft.com") {
#!ifdef WITH_EXTERNAL1
		xlog("L_ERROR","Responding to Microsoft Teams Keepalive Option\n");
		append_hf("Contact: <sip:sbc.lordsomerscamp.org.au:SIPS_PORT;transport=tls>\r\n");
#!endif
	}
}
#!endif
